<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Matheus Borba | Portfólio</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="container">
    <aside class="sidebar">
      <div class="folder">📁 mthperera</div>
      <ul class="file-tree">
        <li class="file-item"><span class="icon">📝</span><a href="#" onclick="openTab('readme')">README.md</a></li>
      
        <li class="folder-toggle">
          <div class="folder-click" onclick="toggleFolder(this)">
            <span class="icon arrow">▶</span>
            <span class="icon">📁</span>
            <span class="folder-label">projetos/</span>
          </div>
          <ul class="subfolder">
            <li><span class="line"></span><a href="#" onclick="openTab('resumo')">📄 resumo.txt</a></li>
            <li><span class="line"></span><a href="#" onclick="openTab('fosforo')">📝 fosforo.md</a></li>
            <li><span class="line"></span><a href="#" onclick="openTab('raman')">📝 raman.md</a></li>
            <li><span class="line"></span><a href="#" onclick="openTab('rayleigh')">📝 rayleigh.md</a></li>
            <li><span class="line"></span><a href="#" onclick="openTab('alice')">📝 alice.md</a></li>
            <li><span class="line"></span><a href="#" onclick="openTab('supercondutores')">📝 supercondução.md</a></li>
            <li><span class="line"></span><a href="#" onclick="openTab('dino-ai')">📝 dino-ai.md</a></li>
          </ul>
        </li>
        
      
        <li class="file-item"><span class="icon">🏅</span><a href="#" onclick="openTab('conquistas')">conquistas.md</a></li>
        <li class="file-item"><span class="icon">📄</span><a href="#" onclick="openTab('contato')">contato.txt</a></li>
      </ul>
      
    </aside>
    

    <main class="main">
      <div class="tabs" id="tabs"></div>

      <div class="content" id="content">
        <section id="readme" class="section">
          <h2>README</h2>
        
          <p><strong>Nome:</strong> Matheus Henrique Pereira Borba</p>
          <p><strong>Curso:</strong> Ciência da Computação — Insper (bolsista integral)</p>
        
          <h3>🧠 Sobre mim</h3>
          <p>
            Tenho mais de 100 medalhas em olimpíadas científicas nacionais e internacionais. Me interesso por ciência aplicada, programação e pesquisa — especialmente quando envolvem física, química e inteligência artificial.
            Gosto de construir projetos que exploram desde simulações e espectroscopia até jogos autorais e modelos preditivos com redes neurais.
          </p>
        
          <h3>📁 Projetos em destaque</h3>
          <ul>
            <li><strong>📦 Previsão de fósforo em caixas fechadas:</strong> abordagem física e estatística baseada em som — IYPT 2024</li>
            <li><strong>🧪 Espectroscopia Raman aplicada a polímeros:</strong> reconstrução molecular com dados experimentais — IYPT 2025</li>
            <li><strong>🔥 Convecção Rayleigh-Bénard:</strong> análise de células térmicas com controle de contorno e visualização — IYPT 2025</li>
            <li><strong>❄️ Previsão de temperatura crítica de supercondutores:</strong> regressão com redes neurais em PyTorch</li>
            <li><strong>🎮 Alice vs Rainhas:</strong> jogo estilo Cuphead com física, chefes e sistema de ranking</li>
            <li><strong>🦖 Dino AI com NEAT:</strong> agente que aprende a jogar o dinossauro do Chrome por evolução de redes</li>
          </ul>
        
          <h3>🎯 Objetivos</h3>
          <p>
            Quero aplicar ciência e tecnologia para resolver problemas reais — seja prevendo propriedades de materiais, automatizando tarefas ou criando experiências interativas. Busco sempre unir raciocínio físico com soluções computacionais.
          </p>
        
          <h3>📎 Extras</h3>
          <p>
            Para mais informações, veja meu <a href="#" onclick="openTab('contato')">contato.txt</a> ou conheça minhas <a href="#" onclick="openTab('conquistas')">🏅 conquistas.md</a>.
          </p>
        </section>
        
        
        

        <section id="resumo" class="section">
          <h2>Projetos em Destaque</h2>
          <ul>
            <li>
              <strong>📦 Previsão da quantidade de fósforo dentro de uma caixinha</strong><br />
              Projeto experimental do <a href="https://iypt.org.br/problemas-2024/" target="_blank">IYPT Brasil 2024</a>, onde investiguei a distribuição de fósforo em caixas lacradas usando métodos indiretos. A proposta envolvia reconstruir propriedades internas com medições externas, exigindo raciocínio físico e estatístico.
            </li>
            <br />
        
            <li>
              <strong>🧪 Reconstrução de estrutura molecular de polímero</strong><br />
              Projeto baseado na espectroscopia Raman, utilizando um espectrômetro da UFC. O objetivo foi estudar o padrão molecular de materiais como o isopor, vinculando os espectros obtidos a propriedades físicas reais. Também parte dos problemas da <a href="https://iypt.org.br/problemas-2025/" target="_blank">IYPT Brasil 2025</a>.
            </li>
            <br />
        
            <li>
              <strong>🔥 Análise laboratorial da convecção de Rayleigh-Bénard</strong><br />
              Estudo experimental do fenômeno de convecção térmica em fluidos sob gradientes de temperatura. O problema faz parte da <a href="https://iypt.org.br/problemas-2025/" target="_blank">IYPT Brasil 2025</a> e envolve análise visual, identificação de padrões de células convectivas e compreensão dos fatores físicos que influenciam o comportamento do fluido aquecido.
            </li>
            
            <br />
        
            <li>
              <strong>🎮 Alice - Cuphead Style</strong><br />
              Um jogo feito em Pygame inspirado no estilo retrô de Cuphead. Nele, Alice enfrenta chefes como a Rainha Vermelha e os gêmeos Tweedledee e Tweedledum em combates aéreos e terrestres. Contém física customizada, jogo por meio de joystick e sistema de pontuação.  
              <a href="https://github.com/mthperera/cuphead-alice" target="_blank">🔗 Repositório no GitHub</a>
            </li>
            <br />
        
            <li>
              <strong>❄️ Previsão da temperatura crítica de supercondutores</strong><br />
              Projeto de machine learning usando regressão e redes neurais em PyTorch para prever a temperatura crítica (Tc) de materiais supercondutores com base em sua composição química.  
              <a href="https://github.com/mthperera/predict-critical-temperature" target="_blank">🔗 Repositório no GitHub</a>
            </li>
            <br />
        
            <li>
              <strong>🦖 Dino AI com NEAT</strong><br />
              Um agente evolutivo que aprende a jogar o jogo do dinossauro do Chrome usando o algoritmo NEAT (NeuroEvolution of Augmenting Topologies). O projeto envolve detecção de obstáculos e tomada de decisão com redes neurais evolutivas.  
              <a href="https://github.com/mthperera/dino-ai" target="_blank">🔗 Repositório no GitHub</a>
            </li>
          </ul>
        </section>        

        <section id="fosforo" class="section">
          <h2>📦 Previsão da quantidade de fósforos</h2>
        
          <p>
            Inspirado no <strong>Problema 1 da IYPT 2024</strong>, este projeto investigou como estimar o número de objetos (como fósforos ou balas) dentro de uma caixa <em>sem abri-la</em>, apenas analisando o som produzido ao sacudi-la.
          </p>
        
          <h3>🔊 Fundamentos Físicos</h3>
          <p>
            As colisões entre os objetos — e entre objetos e as paredes — geram ondas sonoras cuja <strong>intensidade</strong> e <strong>frequência</strong> dependem de variáveis como:
          </p>
          <ul>
            <li>grau de empacotamento (Φ);</li>
            <li>energia cinética média;</li>
            <li>geometria e material da caixa;</li>
            <li>número total de partículas \( N \).</li>
          </ul>
        
          <h3>📈 Modelo Teórico</h3>
            <p>
              Modelamos o sistema como um gás granular confinado. A complexidade do som emitido está ligada à <strong>entropia do sistema</strong>, que por sua vez depende do número de microestados acessíveis — representados por pontos no <strong>espaço de fases de \(6N\) dimensões</strong>, com \(3N\) coordenadas de posição e \(3N\) de momento.
            </p>

            <p>
              Assumindo partículas indistinguíveis e desprezando rotações e posições absolutas, o número de microestados disponíveis para \(N\) partículas com energia total \(E\) e volume \(V\) pode ser estimado como:
            </p>

            <p>
              $$ \Omega \propto \frac{V^N \cdot E^{\frac{3N}{2}}}{N! \cdot h^{3N}} $$
            </p>

            <p>
              Onde \(h\) é a constante de Planck, garantindo que cada célula no espaço de fases tenha volume mínimo \(\sim h^{3N}\), conforme o <strong>princípio da incerteza de Heisenberg</strong>. A entropia associada é dada por:
            </p>

            <p>
              $$ S = k_B \ln \Omega $$
            </p>

            <p>
              A região acessível do espaço de fases é uma <strong>hiperesfera de \(6N\) dimensões</strong> centrada na origem, cujo raio depende da raiz quadrada da energia total. À medida que o número de partículas ou a energia aumenta, o volume dessa hiperesfera (e, portanto, a entropia) cresce rapidamente.
            </p>

            <p>
              Isso implica que, para sistemas com baixa entropia (por exemplo, quando a caixa está cheia e as partículas estão restritas), o som gerado pelas colisões torna-se mais <strong>previsível</strong> e <strong>silencioso</strong>. Já para altos valores de entropia (caixas parcialmente cheias), o som é mais <strong>aleatório</strong> e <strong>intenso</strong>.
            </p>

            <p>
              A intensidade sonora \( I \) foi ajustada empiricamente como uma <strong>curva de Poisson</strong> em função do grau de empacotamento Φ:
            </p>

            <p>
              $$ I(\Phi) = A \cdot \Phi^k \cdot e^{-\lambda \Phi} $$
            </p>

            <p>
              com \(A\), \(k\) e \(\lambda\) ajustados para diferentes combinações de objeto e caixa.
            </p>
        
          <h3>🎤 Montagem Experimental</h3>
          <ul>
            <li>Microfone passivo (41 kHz de amostragem);</li>
            <li>Interface com Phantom Power;</li>
            <li>Rotacionador + caixas variadas com objetos;</li>
            <li>Registro dos sons e conversão para espectrogramas Mel.</li>
          </ul>
        
          <h3>🧠 Rede Neural</h3>
          <p>
            Utilizamos uma rede neural leve que recebeu como entrada o espectrograma Mel do som gravado. O modelo conseguiu prever \( N \) com <strong>erro médio quadrático abaixo de 10%</strong> em configurações conhecidas.
          </p>
        
          <h3>📊 Resultados</h3>
          <p>
            Observamos que o aumento do <em>grau de empacotamento</em> reduz a entropia acústica — ou seja: <strong>quanto mais cheia a caixa, mais silencioso e previsível o som</strong>.
          </p>
          <p>
            A frequência de colisões foi modelada com base na distribuição de velocidades de Maxwell-Boltzmann:
          </p>
          <p>
            $$ f \propto \sqrt{\frac{kT}{m}} \cdot \frac{N}{V} $$
          </p>
        
          <h3>🎯 Conclusão</h3>
          <p>
            Este projeto uniu <strong>termodinâmica estatística</strong>, <strong>acústica</strong>, <strong>redes neurais</strong> e <strong>modelagem matemática</strong> para transformar uma simples caixa sacudida em uma balança acústica capaz de estimar sua carga com precisão.
          </p>
        </section>        
        
        
        <section id="raman" class="section">
          <h2>🧪 Análise Raman de Polímeros</h2>
        
          <p>
            Este projeto, parte do <strong>Problema 17 da IYPT 2025</strong>, teve como objetivo explicar o efeito Raman em polímeros orgânicos (como o isopor) e determinar sua estrutura molecular a partir do espectro Raman. A proposta envolveu desde coleta experimental com espectrômetro da UFC até modelagem computacional por DFT (Density Functional Theory).
          </p>
        
          <h3>🌈 Efeito Raman</h3>
          <p>
            Quando uma amostra é irradiada com um laser, a luz espalhada pode ter energia diferente da luz incidente. Isso se deve ao espalhamento inelástico de fótons, conhecido como <strong>efeito Raman</strong>, que revela os modos vibracionais da molécula.
          </p>
        
          <p>
            As componentes principais são:
            <ul>
              <li><strong>Espalhamento Stokes:</strong> fóton perde energia → \( \lambda_{espalhada} > \lambda_{laser} \)</li>
              <li><strong>Espalhamento Anti-Stokes:</strong> fóton ganha energia → \( \lambda_{espalhada} < \lambda_{laser} \)</li>
            </ul>
          </p>
        
          <p>
            O deslocamento Raman é dado por:
            </p>
            <p>
            $$ \Delta \nu = \left( \frac{1}{\lambda_0} - \frac{1}{\lambda_1} \right) $$
            </p>
            <p>
            E sua energia associada:
            </p>
            <p>
            $$ \Delta E = h \cdot \Delta \nu \cdot c $$
          </p>
        
          <h3>🔬 Montagem Experimental</h3>
          <p>
            Os espectros foram obtidos no <strong>espectrômetro de Raman do Departamento de Física da UFC</strong>, com as seguintes condições:
            <ul>
              <li>Laser He-Ne (632,8 nm), 15 mW</li>
              <li>Detector CCD resfriado (-70°C)</li>
              <li>Objetivas de 10x a 100x</li>
              <li>Coleta com <code>Labspec 5</code> e análise com <code>OriginPro</code></li>
            </ul>
          </p>
        
          <h3>🧪 Polímeros Investigados</h3>
          <p>
            Foram testadas amostras como:
            <ul>
              <li>Polietileno Glicol (MM 400, 4000, 10000)</li>
              <li>Polivinilpirrolidona</li>
              <li>Polipropileno / Polipropileno de alta carga</li>
              <li>Cera de polietileno, Poliisopreno, PVA, etc.</li>
            </ul>
          </p>
        
          <h3>📊 Análise Computacional</h3>
          <p>
            Utilizamos o software <strong>Gaussian</strong> com estruturas modeladas no <strong>Avogadro 2</strong> para prever espectros teóricos de Raman usando a técnica DFT. Os espectros teóricos foram comparados com os experimentais por <strong>similaridade cosseno</strong>:
          </p>
        
          <p>
            $$ \text{SC} = \frac{A \cdot B}{\|A\| \|B\|} $$
          </p>
        
          <p>
            Essa métrica ignora diferenças de intensidade absoluta, focando na forma dos espectros. Isso torna o processo robusto contra ruídos e variações de calibração.
          </p>
        
          <h3>📉 Resultados</h3>
          <p>
            Observamos que:
            <ul>
              <li>Impurezas causam picos difusos ou ombros</li>
              <li>Alterações na cristalinidade modificam a largura dos picos</li>
              <li>A massa molecular afeta a posição dos modos vibracionais</li>
            </ul>
            Também foi possível estimar a <strong>estrutura química</strong> com precisão razoável a partir do espectro medido.
          </p>
        
          <p>
            A figura a seguir ilustra um dos espectros obtidos e o ajuste feito:
          </p>
          <p>
            $$ \text{Exemplo de pico: } 1448 \, \text{cm}^{-1} \quad (\text{C–H deformação}) $$
          </p>
        
          <h3>📚 Conclusão</h3>
          <p>
            Este projeto uniu <strong>física quântica, espectroscopia e aprendizado de máquina</strong> para identificar polímeros através de assinaturas vibracionais. O modelo teórico foi validado experimentalmente, e os resultados indicam que a espectroscopia Raman é uma ferramenta poderosa para análise não destrutiva de materiais orgânicos.
          </p>
        </section>
        
        
        <section id="rayleigh" class="section">
          <h2>🔥 Convecção de Rayleigh-Bénard em Suspensões</h2>
        
          <p>
            Este projeto, baseado no <strong>Problema 10 da IYPT 2025</strong>, investigou a formação de <strong>padrões convectivos auto-organizados</strong> em fluidos aquecidos de baixo para cima. Em particular, estudamos como a suspensão de pós (como mica, glitter e grafite) em óleos afeta o surgimento das chamadas <em>células de Bénard</em>.
          </p>
        
          <h3>🌡️ Fenômeno Físico</h3>
          <p>
            A convecção de Rayleigh-Bénard ocorre quando um fluido entre duas placas horizontais é aquecido por baixo e resfriado por cima. A diferença de temperatura induz uma diferença de densidade que gera empuxo. Se esse empuxo for suficientemente forte para superar a dissipação viscosa e a difusão térmica, surgem padrões organizados de movimento — as <strong>células hexagonais</strong>.
          </p>
        
          <p>
            A condição crítica é dada pelo <strong>Número de Rayleigh</strong>:
          </p>
        
          <p>
            $$ \mathrm{Ra} = \frac{g \alpha \Delta T H^3}{\nu \kappa} $$
          </p>
        
          <ul>
            <li>\( g \): gravidade</li>
            <li>\( \alpha \): coeficiente de expansão térmica</li>
            <li>\( \Delta T \): diferença de temperatura</li>
            <li>\( H \): altura da camada de fluido</li>
            <li>\( \nu \): viscosidade cinemática</li>
            <li>\( \kappa \): difusividade térmica</li>
          </ul>
        
          <p>
            O fenômeno só se inicia quando \( \mathrm{Ra} > \mathrm{Ra}_\text{crítico} \approx 1708 \).
          </p>
        
          <h3>🧪 Montagem Experimental</h3>
          <p>
            Utilizamos placas de Petri de diferentes tamanhos preenchidas com óleos (silicone, rícino, glicerina, etc.) e partículas em suspensão. O fundo foi aquecido por uma chapa térmica com controle via Arduino. A parte superior manteve-se isolada termicamente com madeira e putrescina.
          </p>
        
          <p>
            Equipamentos utilizados:
            <ul>
              <li>Microscópio USB</li>
              <li>Viscosímetro e densímetro para caracterizar os fluidos</li>
              <li>Câmera térmica para validar isolamento</li>
              <li>Software Axio Vision e OriginPro para análise</li>
            </ul>
          </p>
        
          <h3>📏 Medidas e Resultados</h3>
          <p>
            A análise quantitativa envolveu medir:
            <ul>
              <li><strong>Tempo de formação das células</strong>: depende da viscosidade e condutividade térmica do óleo.</li>
              <li><strong>Tamanho médio das células</strong>: cerca de 5,2 mm para uma placa de 5 cm de raio.</li>
              <li><strong>Formato</strong>: células hexagonais surgem naturalmente por minimização de energia.</li>
              <li><strong>Influência do pó:</strong> concentrações altas (\( \phi > 10\% \)) causam distorção dos padrões.</li>
            </ul>
          </p>
        
          <h3>📐 Modelagem Matemática</h3>
          <p>
            O regime convectivo depende de vários números adimensionais:
          </p>
        
          <ul>
            <li><strong>Número de Prandtl:</strong> \( \mathrm{Pr} = \nu / \kappa \)</li>
            <li><strong>Número de Grashof:</strong> \( \mathrm{Gr} = \frac{g \alpha \Delta T H^3}{\nu^2} \)</li>
            <li><strong>Número de Nusselt:</strong> \( \mathrm{Nu} > 1 \Rightarrow \) convecção efetiva</li>
          </ul>
        
          <p>
            Fluidos com alta viscosidade (Pr alto) tendem a formar células maiores e menos numerosas. O comportamento caótico foi modelado pela <strong>intermitência de Lorenz</strong>, observada quando \( \mathrm{Ra} \gg 10^4 \).
          </p>
        
          <h3>⚠️ Interferências: Efeito Marangoni</h3>
          <p>
            Camadas finas de fluido e grandes gradientes de temperatura induzem o <strong>efeito Marangoni</strong>, em que diferenças de tensão superficial na interface líquido-ar causam fluxos horizontais que competem com as células de Rayleigh-Bénard. Esse efeito foi visível em óleos de baixa viscosidade como o silicone.
          </p>
        
          <h3>📊 Conclusão</h3>
          <p>
            Demonstramos experimentalmente o surgimento de padrões convectivos e como eles dependem criticamente de fatores físicos como viscosidade, densidade, tipo de pó e controle térmico. O projeto combinou <strong>mecânica dos fluidos, termodinâmica e análise estatística</strong> para explicar visualmente um dos fenômenos mais belos da física: a auto-organização espontânea.
          </p>
        </section>
        
        
        <section id="alice" class="section">
          <h2>🎮 Alice no estilo Cuphead</h2>
        
          <p>
            Inspirado na estética vintage de <strong>Cuphead</strong>, este jogo foi desenvolvido em Python com <code>Pygame</code> e traz a personagem <strong>Alice</strong> enfrentando chefes peculiares em combates laterais e aéreos. Todos os sprites, controles e fases foram criados do zero, com destaque para o visual retrô, sistema de pontuação e suporte completo a joystick.
          </p>
        
          <h3>🎮 Jogabilidade</h3>
          <p>
            O jogador controla Alice em duas modalidades:
            <ul>
              <li><strong>Fase aérea:</strong> Alice pilota uma xícara voadora, com movimentação livre, desviando de projéteis e enfrentando chefes no céu.</li>
              <li><strong>Fase terrestre:</strong> Alice percorre cenários laterais enfrentando inimigos clássicos em estilo plataforma com pulo e disparos.</li>
            </ul>
          </p>
        
          <h3>👾 Inimigos e Chefes</h3>
            <p>
              O jogo apresenta três fases principais, cada uma com seu próprio chefe, desafios e ambientações únicas:
            </p>

            <ul>
              <li>
                <strong>1️⃣ Rainha de Copas:</strong> Invoca cartas assassinas que perseguem Alice e desencadeia uma chuva de corações danosos. A batalha acontece em um cenário realista de jardim mágico. Alice precisa derrotá-la para seguir sua jornada.
              </li>
              <li>
                <strong>2️⃣ Tweedledum & Tweedledee:</strong> Uma fase aérea onde Alice pilota a <em>Rainha Xícara</em>. Os gêmeos atacam usando naves e padrões de projéteis com ovos e ioiôs giratórios. Exige agilidade e movimentação precisa.
              </li>
              <li>
                <strong>3️⃣ Rainha Vermelha:</strong> A batalha final ocorre sobre um tabuleiro de xadrez flutuante. A Rainha invoca peças de xadrez animadas e livros voadores encantados. Alice deve vencer para libertar a Rainha Branca e restaurar a ordem.
              </li>
            </ul>

        
          <h3>🕹️ Controles e Interface</h3>
          <p>
            O jogo é compatível com controle de Xbox, com navegação por teclado virtual e menus estilizados como em editores de texto retrô. A HUD mostra a vida, pontuação e progresso da fase.
          </p>
        
          <h3>🎵 Som e Trilha</h3>
          <p>
            O jogo possui:
            <ul>
              <li>🔊 <strong>Trilha sonora dinâmica</strong> para cada fase e chefe;</li>
              <li>🔊 <strong>Efeitos sonoros</strong> distintos para disparos, colisões e dano;</li>
              <li>🔊 Gerenciamento de camadas de som via canais do Pygame.</li>
            </ul>
          </p>
        
          <h3>🏆 Ranking e Sistema de Pontuação</h3>
          <p>
            Após vencer um chefe, o jogador recebe uma pontuação com base em critérios como tempo de conclusão e número de acertos. As pontuações são salvas localmente em um arquivo <code>ranking.json</code> e exibidas no menu.
          </p>
        
          <h3>🔗 Repositório no GitHub</h3>
          <p>
            Código-fonte completo e instruções para rodar o jogo estão disponíveis em:<br />
            <a href="https://github.com/mthperera/cuphead-alice" target="_blank">🔗 github.com/mthperera/cuphead-alice</a>
          </p>
        </section>
        
        
        
        <section id="supercondutores" class="section">
          <h2>❄️ Previsão da Temperatura Crítica de Supercondutores</h2>
        
          <p>
            Este projeto utiliza <strong>machine learning</strong> e <strong>redes neurais</strong> para prever a <em>temperatura crítica</em> (\( T_c \)) de materiais supercondutores a partir de suas propriedades químicas e físicas. A proposta integra física do estado sólido, engenharia de atributos e modelagem estatística com <code>PyTorch</code>.
          </p>
        
          <h3>📊 Objetivo</h3>
          <p>
            Prever \( T_c \), o ponto no qual a resistividade elétrica de um material zera, utilizando apenas informações sobre sua composição química. O modelo substitui testes laboratoriais caros por predições automáticas baseadas em dados.
          </p>
        
          <h3>🔬 Dataset</h3>
          <p>
            Utilizamos o <a href="https://archive.ics.uci.edu/dataset/446/superconductivty+data" target="_blank">Superconductivity Dataset</a> da UCI, contendo:
            <ul>
              <li>21.000 amostras de compostos químicos;</li>
              <li>80 atributos físico-químicos (média, entropia, densidade atômica, etc.);</li>
              <li>Temperatura crítica real como alvo de regressão.</li>
            </ul>
          </p>
        
          <h3>🧠 Modelagem</h3>
          <p>
            Foram testados modelos de regressão tradicional e redes neurais profundas. As etapas incluíram:
            <ul>
              <li>Pré-processamento com <code>StandardScaler</code>;</li>
              <li>Transformação alvo com raiz quadrada para suavizar a distribuição;</li>
              <li>Treinamento de redes <code>PyTorch</code> com função de perda <code>MSELoss</code> e otimização <code>Adam</code>;</li>
              <li>Reversão da transformação para avaliar \( T_c \) real.</li>
            </ul>
          </p>
        
          <h3>📈 Métricas</h3>
          <p>
            Avaliamos os modelos usando:
            <ul>
              <li><strong>MAE (Erro Absoluto Médio):</strong> em Kelvin</li>
              <li><strong>RMSE:</strong> raiz do erro quadrático médio</li>
              <li><strong>\( R^2 \):</strong> coeficiente de determinação</li>
            </ul>
          </p>
        
          <p>
            Após normalização e inversão das transformações, os melhores modelos apresentaram \( R^2 > 0{,}92 \) e erro médio inferior a 5 K.
          </p>
        
          <h3>💡 Resultados e Conclusão</h3>
          <p>
            Mostramos que é possível prever a temperatura crítica de um supercondutor com alta precisão usando apenas suas propriedades químicas. Este modelo serve como um exemplo de como machine learning pode acelerar pesquisas em materiais avançados.
          </p>
        
          <h3>🔗 Repositório no GitHub</h3>
          <p>
            Acesse o código-fonte e os notebooks do projeto:<br />
            <a href="https://github.com/mthperera/predict-critical-temperature" target="_blank">🔗 github.com/mthperera/predict-critical-temperature</a>
          </p>
        </section>
        
        
        <section id="dino-ai" class="section">
          <h2>🦖 Dino AI com NEAT</h2>
        
          <p>
            Este projeto recria o clássico jogo do <strong>dinossauro do Chrome</strong>, mas com um diferencial: o personagem aprende a jogar sozinho! A inteligência artificial foi treinada usando o algoritmo <strong>NEAT (NeuroEvolution of Augmenting Topologies)</strong>, permitindo que redes neurais evoluam e se adaptem para maximizar a pontuação.
          </p>
        
          <h3>🎮 Mecânica do Jogo</h3>
          <p>
            O dinossauro corre automaticamente por um deserto infinito, desviando de cactos. O desafio consiste em pular no tempo certo.
          </p>
        
          <h3>🧬 Algoritmo NEAT</h3>
          <p>
            O NEAT é um algoritmo de evolução de redes neurais que começa com topologias simples e as complexifica com o tempo. A cada geração:
            <ul>
              <li>Os dinossauros jogam individualmente;</li>
              <li>Redes neurais são avaliadas pela <strong>pontuação alcançada</strong> (fitness);</li>
              <li>Os melhores genomas são cruzados e mutados para formar a próxima geração;</li>
              <li>As topologias e pesos são ajustados automaticamente.</li>
            </ul>
          </p>
        
          <h3>👁️‍🗨️ Entrada e Decisão</h3>
          <p>
            Cada dinossauro toma decisões com base em:
            <ul>
              <li>Distância até os dois próximos obstáculos;</li>
            </ul>
            A rede decide entre: <code>pular</code>, <code>abaixar</code> ou <code>não fazer nada</code>.
          </p>
        
          <h3>📈 Resultados</h3>
          <p>
            Após poucas gerações, a IA aprende a ultrapassar obstáculos com consistência. Com mais tempo de evolução, surgem redes neurais extremamente eficientes, capazes de atingir pontuações altíssimas. O projeto demonstra na prática como <strong>seleção natural + redes neurais</strong> podem resolver problemas complexos de controle em tempo real.
          </p>
        
          <h3>🔗 Repositório no GitHub</h3>
          <p>
            Código-fonte completo e instruções para rodar a simulação estão em:<br />
            <a href="https://github.com/mthperera/dino-ai" target="_blank">🔗 github.com/mthperera/dino-ai</a>
          </p>
        </section>
           

        <section id="conquistas" class="section">
          <h2>Conquistas</h2>
          <p>
            Conquistei mais de 100 medalhas em olimpíadas científicas nacionais e internacionais — incluindo mais de 40 de ouro, 20 de prata, 20 de bronze e mais de 10 menções honrosas.
          </p>
          <ul>
            <li>🥇 <strong>Ouro</strong> na Olimpíada Brasileira de Química (OBQ) – 2023, 2024</li>
            <li>🥇 <strong>Ouro</strong> na OBMEP Nacional – 2024; 🥈 Prata – 2019, 2021, 2023; 🥉 Bronze – 2022</li>
            <li>🥇 <strong>Ouro</strong> na OBMEP Regional – 2023, 2024</li>
            <li>🥉 <strong>Bronze</strong> na Olimpíada Brasileira de Matemática (OBM) – 2021; 🎖️ Menção Honrosa – 2023</li>
            <li>🥉 <strong>Bronze</strong> na Olimpiada de Mayo (Internacional) – 2022</li>
            <li>🥉 <strong>Bronze</strong> no Torneio Internacional de Jovens Físicos (IYPT) – 2024</li>
            <li>🥇 <strong>Ouro</strong> na Olimpíada Brasileira de Física (OBF) – 2021; 🥈 Prata – 2022, 2023; 🥉 Bronze – 2024</li>
            <li>🥇 <strong>Ouro</strong> na Olimpíada Nacional de Ciências (ONC) – 2020, 2021, 2022, 2023, 2024</li>
            <li>🥇 <strong>Ouro</strong> na Olimpíada Brasileira de Astronomia (OBA) – 2020, 2021, 2022, 2024</li>
          </ul>
          <p>Para a lista completa de conquistas, consulte meu <a href="http://lattes.cnpq.br/3616600365153661" target="_blank">currículo Lattes</a>.</p>
        </section>        


        <section id="contato" class="section">
          <h2>Contato</h2>
        
          <div class="contato-item">
            <img src="https://cdn-icons-png.flaticon.com/512/174/174857.png" alt="LinkedIn" class="icon" />
            <div>
              <a href="https://www.linkedin.com/in/matheus-borba-a43a08223/" target="_blank"><strong>LinkedIn</strong></a>
              <p>Veja meu perfil profissional, experiências, conquistas acadêmicas e conexões.</p>
            </div>
          </div>
        
          <div class="contato-item">
            <img src="https://avatars.githubusercontent.com/u/105271783?v=4" alt="GitHub" class="foto" />
            <div>
              <a href="https://github.com/mthperera" target="_blank"><strong>GitHub</strong></a>
              <p>Veja meus repositórios, códigos de projetos em Python, jogos com Pygame, redes neurais e mais.</p>
            </div>
          </div>
        
          <div class="contato-item">
            <img src="https://cdn-icons-png.flaticon.com/512/2306/2306154.png" alt="Lattes" class="icon" />
            <div>
              <a href="http://lattes.cnpq.br/3616600365153661" target="_blank"><strong>Lattes</strong></a>
              <p>Veja meu currículo acadêmico completo, com publicações, prêmios e trajetória científica.</p>
            </div>
          </div>
        </section>        

        
        <section id="terminal"></section>
      </div>
    </main>
  </div>

  <script>
    const tabData = {
      readme:         { label: 'README.md',               icon: '📝' },
      resumo:         { label: 'resumo.txt',              icon: '📄' },
      fosforo:        { label: 'fosforo.md',             icon: '📝' },
      raman:          { label: 'raman.md',               icon: '📝' },
      rayleigh:       { label: 'rayleigh.md',            icon: '📝' },
      alice:          { label: 'alice.md',             icon: '📝' },
      supercondutores:{ label: 'supercondutores.md',      icon: '📝' },
      'dino-ai':      { label: 'dino-ai.md',             icon: '📝' },
      conquistas:     { label: 'conquistas.md',           icon: '🏅' },
      contato:        { label: 'contato.txt',            icon: '📄' }
    };


    const tabsEl = document.getElementById("tabs");
    const terminal = document.getElementById("terminal");

    function openTab(id) {
  // 1) desativa todas as seções
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  
  // 2) ativa a seção clicada
  const section = document.getElementById(id);
  if (!section) {
    console.error(`Seção com ID "${id}" não encontrada.`);
    return;
  }
  section.classList.add('active');

  // 3) mostra o terminal
  terminal.style.display = 'block';

  // 4) ativa aba existente ou cria nova
  const existing = document.getElementById("tab-" + id);
  if (existing) {
    setActiveTab(existing);
    return;
  }

  // cria nova aba
  const tab = document.createElement("div");
  tab.className = "tab active";
  tab.id        = "tab-" + id;
  tab.draggable = true;

  // conteúdo da aba (sem onclick inline no container)
  tab.innerHTML = `
    ${tabData[id].icon} ${tabData[id].label}
    <span class="close">✕</span>
  `;

  // **1. drag handlers** (parte 1 que você já refez)
  tab.addEventListener("dragstart", e => {
    e.dataTransfer.setData("text/plain", id);
    tab.classList.add("dragging");
  });
  tab.addEventListener("dragend", () => {
    tab.classList.remove("dragging");
  });

  // **2. clique na aba** reabre/foca ela
  tab.addEventListener("click", () => openTab(id));

  // **3. fechar sem disparar o click da aba**
  const btn = tab.querySelector(".close");
  btn.addEventListener("click", e => {
    e.stopPropagation();            // evita que o click suba para a aba
    closeTab(e, id);
  });

  tabsEl.appendChild(tab);
  setActiveTab(tab);
  }


    function toggleFolder(element) {
      const subfolder = element.nextElementSibling;
      if (subfolder && subfolder.classList.contains('subfolder')) {
        subfolder.style.display = subfolder.style.display === 'block' ? 'none' : 'block';
        element.querySelector('.arrow').textContent = subfolder.style.display === 'block' ? '▼' : '▶';
      }
    }

    function closeTab(e, id) {
      e.stopPropagation();
      const tab = document.getElementById("tab-" + id);
      const wasActive = tab.classList.contains("active");
      tab.remove();
      document.getElementById(id).classList.remove("active");

      const remaining = document.querySelectorAll(".tab");
      if (remaining.length === 0) {
        terminal.style.display = "none";
        return;
      }

      if (wasActive) {
        const lastId = remaining[remaining.length - 1].id.replace("tab-", "");
        openTab(lastId);
      }
    }

    function setActiveTab(tab) {
      document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
      tab.classList.add("active");
    }

    tabsEl.addEventListener("dragover", e => {
      e.preventDefault();
      const dragging = document.querySelector(".dragging");
      const after = getDragAfterElement(tabsEl, e.clientX);
      if (after == null) {
        tabsEl.appendChild(dragging);
      } else {
        tabsEl.insertBefore(dragging, after);
      }
    });

    tabsEl.addEventListener("drop", e => {
      const dragging = document.querySelector(".dragging");
      if (dragging) {
        const id = dragging.id.replace("tab-", "");
        setTimeout(() => openTab(id), 0); // ativa a aba recém reposicionada
      }
    });

    function getDragAfterElement(container, x) {
      const draggables = [...container.querySelectorAll(".tab:not(.dragging)")];
      return draggables.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = x - box.left - box.width / 2;
        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    window.onload = () => {
      openTab("readme");
      document.querySelectorAll('.subfolder').forEach(folder => folder.style.display = 'none'); // Garante que subpastas estejam fechadas inicialmente
    };
  </script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</body>
</html>